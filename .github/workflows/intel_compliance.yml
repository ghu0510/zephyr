# intel_compliance.yml
# PR project compliance Workflow - PR Event
#
# 1. Sets up environment. Installing required deps and clearing out old files
# 2. Checks out code from internal PR and performs a rebase and west update
# 3. Runs various compliance checks just like upstream project except we omit
#    the codeowners check internally
# 4. If any checks fails returns what has failed as well as uploads the .xml
#    file as an artifact to the job

name: Intel Compliance Checks

on: pull_request

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  check_compliance:
    runs-on: fmos-guest-ubuntu-12c
    container:
      image: amr-registry.caas.intel.com/zephyrproject/ci-lite:v0.24.11
      options: "-v /srv/runner/workspace:/runner/workspace"
      env:
        TOKEN: ${{ secrets.ZEPHYR_TOKEN }}
    name: Run compliance checks on patch series (PR)
    steps:
      # Cleans out any files from previous builds (as well as any .west files)
      - name: Clean
        shell: bash
        run: |
          shopt -s dotglob
          rm -rf *
      - name: Update PATH for west
        run: |
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      # Checkout code from open internal PR
      - name: Checkout the code
        uses: actions/checkout@v3.1.0
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: Environment Setup
        run: |
          touch $HOME/.git-credentials
          touch $HOME/.gitconfig
          git config --global user.email "sys_tmbuild@intel.com"
          git config --global user.name "Github Builder CI"
          git config --global credential.helper 'store --file=$HOME/.git-credentials'
          west init -l . || true
          west config --global update.narrow true
          west config --global update.path-cache "/runner/workspace"
          echo -e "https://$TOKEN:$TOKEN@github.com/intel-innersource/drivers.audio.firmware.converged" > $HOME/.git-credentials
          west update --path-cache /runner/workspace  2>&1 1> west.update.log || ( rm -rf ../intel ../modules ../bootloader ../tools && west update --path-cache /runner/workspace)
          # Using west, add all internal repos to credentials file.
          for r in `west  list -f {url} | grep intel-innersource | sed 's#https://##'`; do
            echo -e "https://$TOKEN:$TOKEN@$r" >> $HOME/.git-credentials
          done
          # debug
          cat $HOME/.git-credentials
          git config --global --add safe.directory ${PWD}
          west -vv update --path-cache /runner/workspace
          west forall -c 'git reset --hard HEAD'

      - name: Rebase Tree
        env:
          BASE_REF: ${{ github.base_ref }}
        run: |
          git rebase origin/${BASE_REF}
          # debug
          git log  --pretty=oneline | head -n 10

      # Run ./scripts/ci/check_compliance.py (maintained upstream) with the
      # same checkers as the project except for codeowners as this will not
      # apply internally
      - name: Run Compliance Tests
        id: compliance
        continue-on-error: true
        env:
          BASE_REF: ${{ github.base_ref }}
        run: |
          pip3 install yamllint
          export ZEPHYR_BASE=$PWD
          git log  --pretty=oneline | head -n 10
          ./scripts/ci/check_compliance.py --annotate -e KconfigBasic -c origin/${BASE_REF}..

      # Upload compliance.xml file to workflow run capturing any errors from
      # the compliance check
      - name: upload-results
        continue-on-error: true
        uses: actions/upload-artifact@master
        with:
          name: compliance.xml
          path: compliance.xml

      # If there are no compliance errors then this step will pass, if failing
      # then will also publish which errors were caught during the check
      - name: check-warns
        shell: bash
        run: |
          if [[ ! -s "compliance.xml" ]]; then
            exit 1;
          fi

          files=($(./scripts/ci/check_compliance.py -l))
          for file in "${files[@]}"; do
            f="${file}.txt"
            if [[ -s $f ]]; then
              errors=$(cat $f)
              errors="${errors//'%'/'%25'}"
              errors="${errors//$'\n'/'%0A'}"
              errors="${errors//$'\r'/'%0D'}"
              echo "::error file=${f}::$errors"
              exit=1
            fi
          done

          if [ "${exit}" == "1" ]; then
            exit 1;
          fi
