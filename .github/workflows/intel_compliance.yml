# intel_compliance.yml
# PR project compliance Workflow - PR Event
#
# 1. Sets up environment. Installing required deps and clearing out old files
# 2. Checks out code from internal PR and performs a rebase and west update
# 3. Runs various compliance checks just like upstream project except we omit
#    the codeowners check internally
# 4. If any checks fails returns what has failed as well as uploads the .xml
#    file as an artifact to the job

name: Intel Compliance Checks

on: pull_request

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  check_compliance:
    runs-on: fmos-ubuntu-latest
    env:
      TOKEN: ${{ secrets.ZEPHYR_TOKEN }}
    name: Run compliance checks on patch series (PR)
    steps:
      # Cleans out any files from previous builds (as well as any .west files)
      - name: Clean
        shell: bash
        continue-on-error: true
        run: |
          shopt -s dotglob
          rm -rf *

      - name: Update PATH for west
        run: |
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      # Checkout code from open internal PR
      - name: Checkout the code
        uses: actions/checkout@v3.1.0
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      # Install required dependencies to run the compliance checks
      - name: Install python dependencies
        run: |
          pip3 install setuptools
          pip3 install wheel
          pip3 install python-magic junitparser==2.7.0 gitlint pylint pykwalify yamllint
          pip3 install west
          pip3 install lxml

      - name: Set Creds for internal repos
        run: |
          touch $HOME/.git-credentials
          touch $HOME/.gitconfig
          git config --global user.email "sys_tmbuild@intel.com"
          git config --global user.name "Github Builder CI"
          git config --global credential.helper 'store --file=$HOME/.git-credentials'
          west init -l . || true
          # Using west, add all internal repos to credentials file.
          for r in `west  list -f {url} | grep intel-innersource | sed 's#https://##'`; do
            echo -e "https://$TOKEN:$TOKEN@$r" >> $HOME/.git-credentials
          done
          # debug
          cat $HOME/.git-credentials
          git config --global --add safe.directory ${PWD}

      - name: Environment Setup
        env:
          BASE_REF: ${{ github.base_ref }}
        run: |
          git rebase origin/${BASE_REF}
          # debug
          git log  --pretty=oneline | head -n 10
          west config --global update.narrow true
          west update 2>&1 1> west.update.log || west update 2>&1 1> west.update2.log
          west forall -c 'git reset --hard HEAD'

      # Run ./scripts/ci/check_compliance.py (maintained upstream) with the
      # same checkers as the project except for codeowners as this will not
      # apply internally
      - name: Run Compliance Tests
        continue-on-error: true
        id: compliance
        env:
          BASE_REF: ${{ github.base_ref }}
        run: |
          export ZEPHYR_BASE=$PWD
          git log  --pretty=oneline | head -n 10
          ./scripts/ci/check_compliance.py -m Devicetree -m Gitlint -m Identity -m Nits -m pylint -m checkpatch -m Kconfig -c origin/${BASE_REF}..

      # Upload compliance.xml file to workflow run capturing any errors from
      # the compliance check
      - name: upload-results
        uses: actions/upload-artifact@master
        continue-on-error: True
        with:
          name: compliance.xml
          path: compliance.xml

      # If there are no compliance errors then this step will pass, if failing
      # then will also publish which errors were caught during the check
      - name: check-warns
        run: |
          if [[ ! -s "compliance.xml" ]]; then
            exit 1;
          fi

          for file in Nits.txt checkpatch.txt Identity.txt Gitlint.txt pylint.txt Devicetree.txt Kconfig.txt Codeowners.txt; do
            if [[ -s $file ]]; then
              errors=$(cat $file)
              errors="${errors//'%'/'%25'}"
              errors="${errors//$'\n'/'%0A'}"
              errors="${errors//$'\r'/'%0D'}"
              echo "::error file=${file}::$errors"
              exit=1
            fi
          done

          if [ "${exit}" == "1" ]; then
            exit 1;
          fi
